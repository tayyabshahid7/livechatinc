import qs from 'qs';
import Cookie from 'js-cookie';

var errors = {
  extend: function (error) {
    if (error.oauth_exception && this.oauth_exception[error.oauth_exception]) {
      return Object.assign(error, {
        description: this.oauth_exception[error.oauth_exception],
      });
    }

    if (
      error.identity_exception &&
      this.identity_exception[error.identity_exception]
    ) {
      return Object.assign(error, {
        description: this.identity_exception[error.identity_exception],
      });
    }

    return error;
  },
  oauth_exception: {
    invalid_request:
      'You may be loading accounts-sdk on a domain that is not whitelisted.',

    unauthorized_client:
      'Client not found, not provided or incorectly configured.',

    access_denied:
      'Probably this application is installed on a different account and you do not have access to it.',

    unsupported_response_type:
      'Provided response type is incorrect or unavailable for a given client.',
  },
  identity_exception: {
    unauthorized: 'Resource owner identity is not known or consent is missing.',
  },
};

/* eslint-disable require-jsdoc */
class Listener {
  constructor(options = {}) {
    this.options = options;
    this.listening = false;

    this.receiveMessage = this.receiveMessage.bind(this);
  }

  start(timeout, callback) {
    if (this._listenerInited) {
      return;
    }
    this.listening = true;
    this.callback = callback;

    if (timeout) {
      this.tid = setTimeout(() => {
        this.stop();
        callback('timeout', null);
      }, timeout);
    }

    window.addEventListener('message', this.receiveMessage);
  }

  stop() {
    this.listening = false;
    clearTimeout(this.tid);
    window.removeEventListener('message', this.receiveMessage, false);
  }

  receiveMessage(event) {
    if (
      event.origin !== this.options.server_url &&
      event.origin !==
        this.options.server_url.replace(/livechat\.com$/, 'livechatinc.com')
    ) {
      return;
    }

    if (!event.data.data && !event.data.error) {
      return;
    }

    this.stop();

    if (event.data.error) {
      this.callback(errors.extend(event.data.error), null);
    } else {
      if (event.data.data.scopes) {
        event.data.data.scope = event.data.data.scopes;
        delete event.data.data.scopes;
      }
      if (event.data.data.expires_in) {
        event.data.data.expires_in = parseInt(event.data.data.expires_in) || 0;
      }
      this.callback(null, event.data.data);
    }
  }
}

/**
 * Class for authentication using popup.
 */
class Popup {
  // eslint-disable-next-line require-jsdoc
  constructor(sdk, options) {
    this.options = options;
    this.sdk = sdk;
  }

  /**
   * run popup authorization flow, should be called in a click handler to avoid beeing blocked
   * @return {Promise} promise that resolves to authorize data or error
   */
  authorize() {
    return new Promise((resolve, reject) => {
      const url = this.sdk.authorizeURL(this.options, 'button');

      const w = 500;
      const h = 650;
      const left = window.screen.width / 2 - w / 2;
      const top = window.screen.height / 2 - h / 2;

      const listener = new Listener(this.options);
      listener.start(null, (err, authorizeData) => {
        if (err) {
          return reject(err);
        }
        resolve(authorizeData);
      });

      var open = function () {
        window.open(
          url,
          'livechat-login-popup',
          `resizable,scrollbars,width=${w},height=${h},left=${left},top=${top}`
        );
      };

      if (document.requestStorageAccess) {
        var promise = document.requestStorageAccess();
        promise.then(open, open);
      } else {
        open();
      }
    });
  }
}

/* eslint-disable require-jsdoc */

/** @fileOverview
 * @author Auth0 https://github.com/auth0/auth0.js
 * @license MIT
 */

function pick(object, keys) {
  return keys.reduce((prev, key) => {
    if (object[key]) {
      prev[key] = object[key];
    }
    return prev;
  }, {});
}

// eslint-disable-next-line require-jsdoc
class Redirect {
  // eslint-disable-next-line require-jsdoc
  constructor(sdk, options) {
    this.options = options;
    this.sdk = sdk;
  }

  /**
   * run default authorization flow
   */
  authorize() {
    const url = this.sdk.authorizeURL(this.options);
    window.location = url;
  }

  /**
   * this function checks if the current origin was redirected to with authorize data
   * @return {Promise} promise that resolves to authorize data or error
   */
  authorizeData() {
    return new Promise((resolve, reject) => {
      let authorizeData = {};
      let requiredFields = [];

      switch (this.options.response_type) {
        case 'token':
          requiredFields = ['access_token', 'expires_in', 'token_type'];

          authorizeData = qs.parse(window.location.hash.substring(1));
          authorizeData = pick(authorizeData, [
            'access_token',
            'expires_in',
            'state',
            'scope',
            'token_type',
          ]);

          if (
            !requiredFields.every((field) =>
              authorizeData.hasOwnProperty(field)
            )
          ) {
            reject(errors.extend({identity_exception: 'unauthorized'}));
            return;
          }

          authorizeData.expires_in = parseInt(authorizeData.expires_in);
          break;

        case 'code':
          requiredFields = ['code'];

          authorizeData = qs.parse(window.location.search, {
            ignoreQueryPrefix: true,
          });
          authorizeData = pick(authorizeData, ['state', 'code']);

          if (
            !requiredFields.every((field) =>
              authorizeData.hasOwnProperty(field)
            )
          ) {
            reject(errors.extend({identity_exception: 'unauthorized'}));
            return;
          }
      }

      this.sdk.redirectUriParamsPersister.retrieve(authorizeData.state);

      resolve(authorizeData);
    });
  }
}

/**
 * Class for authentication using Iframe
 */
class Iframe {
  // eslint-disable-next-line require-jsdoc
  constructor(sdk, options) {
    this.options = options;
    this.sdk = sdk;
  }

  /**
   * run iframe authorization flow, not recommended because of ITP 2.0
   * @return {Promise} promise that resolves to authorize data or error
   */
  authorize() {
    return new Promise((resolve, reject) => {
      const url = this.sdk.authorizeURL(this.options, 'button');

      const listener = new Listener(this.options);

      const cb = (err, authorizeData) => {
        this.removeIframe();
        if (err) {
          return reject(err);
        }
        resolve(authorizeData);
      };

      listener.start(5000, cb);

      const iframe = document.createElement('iframe');
      iframe.setAttribute('src', url);
      iframe.setAttribute('id', this.iframeID());
      iframe.style.width = '1px';
      iframe.style.height = '1px';
      iframe.style.position = 'fixed';
      iframe.style.top = '0';
      iframe.style.right = '0';
      iframe.style.opacity = '0';
      iframe.style.visibility = 'none';

      document.body.appendChild(iframe);
    });
  }

  // eslint-disable-next-line require-jsdoc
  iframeID() {
    return this.options.client_id + this.options.response_type;
  }

  // eslint-disable-next-line require-jsdoc
  removeIframe() {
    const ref = document.getElementById(this.iframeID());
    if (ref && ref.parentNode) {
      ref.parentNode.removeChild(ref);
    }
  }
}

/* eslint-disable require-jsdoc */

/** @fileOverview
 * @author Auth0 https://github.com/auth0/auth0.js
 * @license MIT
 */

function DummyStorage() {}

DummyStorage.prototype.getItem = function () {
  return null;
};

DummyStorage.prototype.removeItem = function () {};

DummyStorage.prototype.setItem = function () {};

/* eslint-disable require-jsdoc */
function CookieStorage() {}

CookieStorage.prototype.getItem = function (key) {
  return Cookie.get(key);
};

CookieStorage.prototype.removeItem = function (key) {
  Cookie.remove(key);
};

CookieStorage.prototype.setItem = function (key, value, options) {
  const params = Object.assign(
    {
      expires: 1, // 1 day

      // After august 2020 chrome changed iframe cookie policy and without
      // those parameters cookies wont we stored properly if document is inside iframe.
      SameSite: 'none',
      Secure: true,
    },
    options
  );
  Cookie.set(key, value, params);
};

/* eslint-disable require-jsdoc */

function StorageHandler(options) {
  this.storage = new CookieStorage();
  if (options.force_local_storage !== true) {
    return;
  }
  try {
    // some browsers throw an error when trying to access localStorage
    // when localStorage is disabled.
    const localStorage = window.localStorage;
    if (localStorage) {
      this.storage = localStorage;
    }
  } catch (e) {
    console.warn(e);
    console.warn('Cant use localStorage. Using CookieStorage instead.');
  }
}

StorageHandler.prototype.failover = function () {
  if (this.storage instanceof DummyStorage) {
    console.warn('DummyStorage: ignore failover');
    return;
  } else if (this.storage instanceof CookieStorage) {
    console.warn('CookieStorage: failing over DummyStorage');
    this.storage = new DummyStorage();
  } else {
    console.warn('LocalStorage: failing over CookieStorage');
    this.storage = new CookieStorage();
  }
};

StorageHandler.prototype.getItem = function (key) {
  try {
    return this.storage.getItem(key);
  } catch (e) {
    console.warn(e);
    this.failover();
    return this.getItem(key);
  }
};

StorageHandler.prototype.removeItem = function (key) {
  try {
    return this.storage.removeItem(key);
  } catch (e) {
    console.warn(e);
    this.failover();
    return this.removeItem(key);
  }
};

StorageHandler.prototype.setItem = function (key, value, options) {
  try {
    return this.storage.setItem(key, value, options);
  } catch (e) {
    console.warn(e);
    this.failover();
    return this.setItem(key, value, options);
  }
};

/* eslint-disable require-jsdoc */

function Storage(options) {
  this.handler = new StorageHandler(options);
}

Storage.prototype.getItem = function (key) {
  const value = this.handler.getItem(key);
  try {
    return JSON.parse(value);
  } catch (_) {
    return value;
  }
};

Storage.prototype.removeItem = function (key) {
  return this.handler.removeItem(key);
};

Storage.prototype.setItem = function (key, value, options) {
  const json = JSON.stringify(value);
  return this.handler.setItem(key, json, options);
};

/* eslint-disable require-jsdoc */

class Transaction {
  constructor(options) {
    this.options = options.transaction;
    this.storage = new Storage(this.options);
  }

  generate(params) {
    // 30 minutes
    this.storage.setItem(
      this.options.namespace + params.state,
      {state: params.state, code_verifier: params.code_verifier},
      {expires: 1 / 48}
    );
  }

  get(state) {
    const transactionData = this.storage.getItem(
      this.options.namespace + state
    );
    this.clear(state);
    return transactionData || {};
  }

  clear(state) {
    this.storage.removeItem(this.options.namespace + state);
  }
}

/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape, module, require, Uint32Array */

/**
 * The Stanford Javascript Crypto Library, top-level namespace.
 * @namespace
 */
var sjcl = {
  /**
   * Symmetric ciphers.
   * @namespace
   */
  cipher: {},

  /**
   * Hash functions.  Right now only SHA256 is implemented.
   * @namespace
   */
  hash: {},

  /**
   * Key exchange functions.  Right now only SRP is implemented.
   * @namespace
   */
  keyexchange: {},

  /**
   * Cipher modes of operation.
   * @namespace
   */
  mode: {},

  /**
   * Miscellaneous.  HMAC and PBKDF2.
   * @namespace
   */
  misc: {},

  /**
   * Bit array encoders and decoders.
   * @namespace
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},

  /**
   * Exceptions.
   * @namespace
   */
  exception: {
    /**
     * Ciphertext is corrupt.
     * @constructor
     */
    corrupt: function (message) {
      this.toString = function () {
        return 'CORRUPT: ' + this.message;
      };
      this.message = message;
    },

    /**
     * Invalid parameter.
     * @constructor
     */
    invalid: function (message) {
      this.toString = function () {
        return 'INVALID: ' + this.message;
      };
      this.message = message;
    },

    /**
     * Bug or missing feature in SJCL.
     * @constructor
     */
    bug: function (message) {
      this.toString = function () {
        return 'BUG: ' + this.message;
      };
      this.message = message;
    },

    /**
     * Something isn't ready.
     * @constructor
     */
    notReady: function (message) {
      this.toString = function () {
        return 'NOT READY: ' + this.message;
      };
      this.message = message;
    },
  },
};
/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray
      ._shiftRight(a.slice(bstart / 32), 32 - (bstart & 31))
      .slice(1);
    return bend === undefined ? a : sjcl.bitArray.clamp(a, bend - bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} blength The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function (a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x,
      sh = Math.floor((-bstart - blength) & 31);
    if (((bstart + blength - 1) ^ bstart) & -32) {
      // it crosses a boundary
      x =
        (a[(bstart / 32) | 0] << (32 - sh)) ^ (a[(bstart / 32 + 1) | 0] >>> sh);
    } else {
      // within a single word
      x = a[(bstart / 32) | 0] >>> sh;
    }
    return x & ((1 << blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }

    var last = a1[a1.length - 1],
      shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(
        a2,
        shift,
        last | 0,
        a1.slice(0, a1.length - 1)
      );
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length,
      x;
    if (l === 0) {
      return 0;
    }
    x = a[l - 1];
    return (l - 1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) {
      return a;
    }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l - 1] = sjcl.bitArray.partial(
        len,
        a[l - 1] & (0x80000000 >> (len - 1)),
        1
      );
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) {
      return x;
    }
    return (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x / 0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0,
      i;
    for (i = 0; i < a.length; i++) {
      x |= a[i] ^ b[i];
    }
    return x === 0;
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i,
      last2 = 0,
      shift2;
    if (out === undefined) {
      out = [];
    }

    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }

    for (i = 0; i < a.length; i++) {
      out.push(carry | (a[i] >>> shift));
      carry = a[i] << (32 - shift);
    }
    last2 = a.length ? a[a.length - 1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(
      sjcl.bitArray.partial(
        (shift + shift2) & 31,
        shift + shift2 > 32 ? carry : out.pop(),
        1
      )
    );
    return out;
  },

  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function (x, y) {
    return [x[0] ^ y[0], x[1] ^ y[1], x[2] ^ y[2], x[3] ^ y[3]];
  },

  /** byteswap a word array inplace.
   * (does not handle partial words)
   * @param {sjcl.bitArray} a word array
   * @return {sjcl.bitArray} byteswapped array
   */
  byteswapM: function (a) {
    var i,
      v,
      m = 0xff00;
    for (i = 0; i < a.length; ++i) {
      v = a[i];
      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
    }
    return a;
  },
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * UTF-8 strings
 * @namespace
 */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = '',
      bl = sjcl.bitArray.bitLength(arr),
      i,
      tmp;
    for (i = 0; i < bl / 8; i++) {
      if ((i & 3) === 0) {
        tmp = arr[i / 4];
      }
      out += String.fromCharCode(((tmp >>> 8) >>> 8) >>> 8);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },

  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [],
      i,
      tmp = 0;
    for (i = 0; i < str.length; i++) {
      tmp = (tmp << 8) | str.charCodeAt(i);
      if ((i & 3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i & 3) {
      out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));
    }
    return out;
  },
};
/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) {
    this._precompute();
  }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return new sjcl.hash.sha256().update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,

  /**
   * Reset the hash state.
   * @return this
   */
  reset: function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },

  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === 'string') {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i,
      b = (this._buffer = sjcl.bitArray.concat(this._buffer, data)),
      ol = this._length,
      nl = (this._length = ol + sjcl.bitArray.bitLength(data));
    if (nl > 9007199254740991) {
      throw new sjcl.exception.invalid('Cannot hash more than 2^53 - 1 bits');
    }

    if (typeof Uint32Array !== 'undefined') {
      var c = new Uint32Array(b);
      var j = 0;
      for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {
        this._block(c.subarray(16 * j, 16 * (j + 1)));
        j += 1;
      }
      b.splice(0, 16 * j);
    } else {
      for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {
        this._block(b.splice(0, 16));
      }
    }
    return this;
  },

  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 8 big-endian words.
   */
  finalize: function () {
    var i,
      b = this._buffer,
      h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);

    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }

    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0, 16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init: [],
  /*
   _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
   */

  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key: [],
  /*
   _key:
     [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
   */

  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0,
      prime = 2,
      factor,
      isPrime;

    function frac(x) {
      return ((x - Math.floor(x)) * 0x100000000) | 0;
    }

    for (; i < 64; prime++) {
      isPrime = true;
      for (factor = 2; factor * factor <= prime; factor++) {
        if (prime % factor === 0) {
          isPrime = false;
          break;
        }
      }
      if (isPrime) {
        if (i < 8) {
          this._init[i] = frac(Math.pow(prime, 1 / 2));
        }
        this._key[i] = frac(Math.pow(prime, 1 / 3));
        i++;
      }
    }
  },

  /**
   * Perform one cycle of SHA-256.
   * @param {Uint32Array|bitArray} w one block of words.
   * @private
   */
  _block: function (w) {
    var i,
      tmp,
      a,
      b,
      h = this._h,
      k = this._key,
      h0 = h[0],
      h1 = h[1],
      h2 = h[2],
      h3 = h[3],
      h4 = h[4],
      h5 = h[5],
      h6 = h[6],
      h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i = 0; i < 64; i++) {
      // load up the input word for this round
      if (i < 16) {
        tmp = w[i];
      } else {
        a = w[(i + 1) & 15];
        b = w[(i + 14) & 15];
        tmp = w[i & 15] =
          (((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
            ((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
            w[i & 15] +
            w[(i + 9) & 15]) |
          0;
      }

      tmp =
        tmp +
        h7 +
        ((h4 >>> 6) ^
          (h4 >>> 11) ^
          (h4 >>> 25) ^
          (h4 << 26) ^
          (h4 << 21) ^
          (h4 << 7)) +
        (h6 ^ (h4 & (h5 ^ h6))) +
        k[i]; // | 0;

      // shift register
      h7 = h6;
      h6 = h5;
      h5 = h4;
      h4 = (h3 + tmp) | 0;
      h3 = h2;
      h2 = h1;
      h1 = h0;

      h0 =
        (tmp +
          ((h1 & h2) ^ (h3 & (h1 ^ h2))) +
          ((h1 >>> 2) ^
            (h1 >>> 13) ^
            (h1 >>> 22) ^
            (h1 << 30) ^
            (h1 << 19) ^
            (h1 << 10))) |
        0;
    }

    h[0] = (h[0] + h0) | 0;
    h[1] = (h[1] + h1) | 0;
    h[2] = (h[2] + h2) | 0;
    h[3] = (h[3] + h3) | 0;
    h[4] = (h[4] + h4) | 0;
    h[5] = (h[5] + h5) | 0;
    h[6] = (h[6] + h6) | 0;
    h[7] = (h[7] + h7) | 0;
  },
};

// eslint-disable-next-line require-jsdoc
function base64URLEncode(str) {
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

var encoding = {
  base64URLEncode: base64URLEncode,
};

/* eslint-disable require-jsdoc */

class Persister {
  constructor(options, type) {
    this.options = {
      namespace: options.transaction.namespace + type,
    };
    this.storage = new Storage(this.options);
  }

  set(state, data) {
    this.storage.setItem(this.options.namespace + state, data, {
      expires: 1 / 48,
    });
  }

  get(state) {
    const data = this.storage.getItem(this.options.namespace + state);
    this.clear(state);
    return data || {};
  }

  clear(state) {
    this.storage.removeItem(this.options.namespace + state);
  }
}

/* eslint-disable require-jsdoc */

class RedirectUriParamsPersister {
  constructor(options) {
    this.persister = new Persister(options, 'redirect_uri_params');
  }

  /**
   * Clears query and hash params from redirect_uri and persists them in storage
   * @param {Object} params
   */
  persist(params) {
    const redirectUrl = new URL(params.redirect_uri);
    const queryParams = qs.parse(redirectUrl.search.substring(1));
    const hashParams = qs.parse(redirectUrl.hash.substring(1));

    this.persister.set(params.state, {
      query_params: queryParams,
      hash_params: hashParams,
    });

    params.redirect_uri = redirectUrl.origin + redirectUrl.pathname;
  }

  /**
   * Retrieves persisted query and hash params from storage and updates current location accordingly.
   * Params returned by global accounts overrides persisted params in case of duplications.
   * @param {Object} state
   */
  retrieve(state) {
    const redirectUriParams = this.persister.get(state, false);

    if (!redirectUriParams) {
      return;
    }

    const queryParams = {
      ...(redirectUriParams.query_params ?? {}),
      ...qs.parse(window.location.search.substring(1)),
    };

    const hashParams = {
      ...(redirectUriParams.hash_params ?? {}),
      ...qs.parse(window.location.hash.substring(1)),
    };

    let uri = window.location.origin + window.location.pathname;

    if (queryParams) {
      uri += '?' + qs.stringify(queryParams);
    }

    if (hashParams) {
      uri += '#' + qs.stringify(hashParams);
    }

    window.history.replaceState({}, document.title, uri);
  }
}

/* eslint-disable require-jsdoc */

/** @fileOverview
 * @author Auth0 https://github.com/auth0/auth0.js
 * @license MIT
 */

function string(length) {
  const bytes = new Uint8Array(length);
  const result = [];
  const charset =
    '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._~';

  const cryptoObj = window.crypto || window.msCrypto;
  let random = '';
  if (!cryptoObj) {
    for (let i = 0; i < length; i++) {
      random += charset.charAt(Math.floor(Math.random() * charset.length));
    }
  } else {
    random = cryptoObj.getRandomValues(bytes);
  }

  for (let a = 0; a < random.length; a++) {
    result.push(charset[random[a] % charset.length]);
  }

  return result.join('');
}

var random = {
  string: string,
};

/**
 * Accounts SDK main class
 */
class AccountsSDK {
  /**
   * Accounts SDK constructor
   *
   * @constructor
   * @param {Object} options
   * @param {String} options.client_id registered client ID
   * @param {String} options.organization_id organization ID
   * @param {String} [options.prompt=''] use `consent` to force consent prompt in popup and redirect flows
   * @param {String} [options.response_type='token'] OAuth response type, use `token` or `code`
   * @param {String} [options.popup_flow='auto'] `auto` - close popup when not required, `manual` - always show popup
   * @param {String} [options.state=''] OAuth state param
   * @param {Boolean} [options.verify_state=true] check if state matches after redirect
   * @param {String} [options.scope=null] request exact scopes - must be configured for a given client id
   * @param {String} [options.redirect_uri=''] OAuth redirect uri - default current location
   * @param {String} [options.email_hint=''] fill in email in forms
   * @param {String} [options.server_url='https://accounts.livechat.com'] authorization server url
   * @param {String} [options.path=''] option to provide a path when loading accounts, for example '/signup'
   * @param {Object} [options.tracking] tracking querystring params
   * @param {Object} [options.transaction] options for transaction manager
   * @param {String} [options.transaction.namespace='com.livechat.accounts'] transaction keys prefix
   * @param {Number} [options.transaction.key_length=32] transaction random state length
   * @param {Boolean} [options.transaction.force_local_storage=false] try to use local storage instead of cookies
   * @param {Object} [options.pkce] PKCE configuration
   * @param {Boolean} [options.pkce.enabled=true] Oauth 2.1 PKCE extension enabled
   * @param {String} [options.pkce.code_verifier] override auto generated code verifier
   * @param {Number} [options.pkce.code_verifier_length=128] code verifier length, between 43 and 128 characters https://tools.ietf.org/html/rfc7636#section-4.1
   * @param {String} [options.pkce.code_challange_method='S256'] code challange method, use `S256` or `plain`
   */
  constructor(options = {}) {
    if (options.client_id == null) {
      throw new Error('client id not provided');
    }

    const defaultOptions = {
      organization_id: '',
      prompt: '',
      response_type: 'token',
      popup_flow: 'auto',
      state: '',
      verify_state: true,
      verify_callback: true,
      scope: null,
      redirect_uri: '',
      email_hint: null,
      server_url: 'https://accounts.livechat.com',
      tracking: {
        utm_source: 'accounts.livechat.com',
        utm_medium: 'accounts-sdk',
      },
      transaction: {
        namespace: 'com.livechat.accounts',
        key_length: 32,
        force_local_storage: false,
      },
      pkce: {
        enabled: true,
        code_verifier_length: 128,
        code_challange_method: 'S256',
      },
    };

    this.options = Object.assign({}, defaultOptions, options);
    this.transaction = new Transaction(this.options);
    this.redirectUriParamsPersister = new RedirectUriParamsPersister(
      this.options
    );
  }

  /**
   * use iframe for authorization
   * @param {Object} options for overriding defaults
   * @return {Object} instance of an iframe flow
   */
  iframe(options = {}) {
    const localOptions = Object.assign({}, this.options, options);
    return new Iframe(this, localOptions);
  }

  /**
   * use popup for authorization
   * @param {Object} options for overriding defaults
   * @return {Object} instance of a popup flow
   */
  popup(options = {}) {
    const localOptions = Object.assign({}, this.options, options);
    return new Popup(this, localOptions);
  }

  /**
   * use redirect for authorization
   * @param {Object} options for overriding defaults
   * @return {Object} instance of a redirect flow
   */
  redirect(options = {}) {
    const localOptions = Object.assign({}, this.options, options);
    return new Redirect(this, localOptions);
  }

  /**
   * create authorization url
   * @param {Object} options for overriding defaults
   * @param {String} flow set 'button' for popup and iframe
   * @return {string} generated url
   */
  authorizeURL(options = {}, flow = '') {
    const localOptions = Object.assign({}, this.options, options);

    if (!localOptions.state) {
      localOptions.state = random.string(localOptions.key_length);
    }

    if (!localOptions.redirect_uri) {
      localOptions.redirect_uri = window.location.href;
    }

    const params = pick(localOptions, [
      'client_id',
      'organization_id',
      'redirect_uri',
      'state',
      'response_type',
      'scope',
      'prompt',
    ]);

    Object.assign(params, localOptions.tracking);

    if (params.scope === null) {
      delete params.scope;
    }

    if (flow != null) {
      params.flow = flow;
    }

    if (localOptions.email_hint) {
      params.email = localOptions.email_hint;
    }

    let url = localOptions.server_url;
    if (localOptions.popup_flow === 'manual') {
      url += '/signin';
    }

    if (localOptions.path) {
      url += localOptions.path;
    }

    if (localOptions.response_type === 'code' && localOptions.pkce.enabled) {
      const codeVerifier =
        localOptions.pkce.code_verifier ||
        random.string(localOptions.pkce.code_verifier_length);

      switch (localOptions.pkce.code_challange_method) {
        case 'S256':
          const codeChallenge = sjcl.hash.sha256.hash(codeVerifier);
          Object.assign(params, {
            code_verifier: codeVerifier,
            code_challenge: encoding.base64URLEncode(codeChallenge),
            code_challenge_method: localOptions.pkce.code_challange_method,
          });
          break;

        default:
          Object.assign(params, {
            code_verifier: codeVerifier,
            code_challenge: codeVerifier,
            code_challenge_method: localOptions.pkce.code_challange_method,
          });
      }
    }

    this.transaction.generate(params);
    this.redirectUriParamsPersister.persist(params);

    delete params.code_verifier;

    return url + '?' + qs.stringify(params);
  }

  /**
   * This function verifies if redirect transaction params are valid.
   * @param {Object} authorizeData authorize data to validate and return transaction state - redirect state, pkce code verifier
   * @return {Object} transaction state if valid, null otherwise
   */
  verify(authorizeData) {
    const transactionData = this.transaction.get(authorizeData.state);

    if (authorizeData.state && this.options.verify_state) {
      if (transactionData.state != authorizeData.state) {
        return null;
      }
    }

    return transactionData;
  }
}

export default AccountsSDK;
//# sourceMappingURL=index.esm.js.map
